# 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술
- 강의소개

- 프로젝트 환경설정
  - 빌드하고 실행하기
    - 스프링 코드를 빌드해서 실행시키기

- 스프링 웹 개발 기초
  - 정적 컨텐츠
    - 매핑되는 컨트롤러가 존재하지않으면 정적 컨텐츠를 찾아 반환함
  - MVC와 템플릿 엔진
    - MVC와 템플릿 엔진에 param 넣어서 사용해보기
  - API
    - @ResponseBody body에 리턴값을 직접 넣어준다는 뜻 / View 이런거 없이 리턴값만 그대로 넘어감
    - static class를 class 안에서 만들면 사용가능
    - class 객체 반환해서 Json 형태로 반환
    - Getter, Setter 설명
      - Java bin 표준 방식이고 Property 방식이라고도함
    - @ResponseBody 원리 설명
      - 문자열이 아니면 기본으론 Json으로 반환함

- 회원 관리 예제 - 백엔드 개발
  - 비즈니스 요구사항 정리
  - 회원 도메인과 리포지토리 만들기
    - 요새는 Optional 사용해서 null 처리함
    - Optional.ofNullable 사용
  - 회원 리포지토리 테스트 케이스 작성
    - Test class는 보통 다른데서 가져다 쓰지 않아서 public class로 만들필요가 없다
    - Test는 순서가 보장이 안됨
    - @AfterEach 사용법 / 사용시 각 테스트마다 호출함
  - 회원 서비스 개발
    - 서비스쪽은 비지니스에 의존적으로 네이밍을 하고, 레포지토리 같은 부분은 좀더 개발스럽게 용어를 선택한다.
    - 서비스딴에서 로직이 쭉 나열되면 메소드로 뽑는게 좋다.
    - 비지니스 로직 구현
  - 회원 서비스 테스트
    - 테스트 같은경우는 한글로 적어도 괜찮다 (영어권 사람이랑 일하는게 아니라면)
    - 테스트 코드는 빌드될때 실제 코드에 포함되지 않음
    - // given// when// then 으로 주석을 달아 놓으면 편함 (무슨 데이터를, 무슨 상황에, 이렇게 나오게)
    - assertThrows(1, 2) 2를 하면 1이 터져야한다
    - 예외처리 테스트하는법

- 스프링 빈과 의존관계
  - 컴포넌트 스캔과 자동 의존관계 설정
    - @Autowired를 쓰면 스프링 컨테이너에 있는 것을 가져와 인자로줌
    - @Service를 class 위에 적으면 스프링이 올라올때 스프링 컨테이너에 등록해줌
    - @Repository로 저장소를 등록함
  - 자바 코드로 직접 스프링 빈 등록하기
    - DI에는 필드 주입, setter 주입, 생성자 주입 3가지 방법이 있고 생성자 주입 방법이 가장 보편적이고 선호된다
    - 상황에 따라 구현 클래스를 변경해야 하면 설정을 통해 스프링 빈으로 등록한다.

- 회원 관리 예제 - 웹 MVC 개발
  - 회원 웹 기능 - 홈 화면 추가
  - 회원 웹 기능 - 등록
  - 회원 웹 기능 - 조회
    - 타임리프 반복문 기능 사용해서 뿌려주기

- 스프링 DB 접근 기술
  - H2 데이터베이스 설치
  - 순수 JDBC
    - application.properties에 spring.datasource를 통해서 갑 넣어주기
    - 순수 JDBC는 20년 전에나 쓰던 과거의 기술로 대충 알고 넘어가자 쓰지 않음
    - 인터페이스를 통해 즉 다형성을 통해 객체지향에 유리
  - 스프링 통합 테스트
    - @SpringBootTest 스프링 컨테이너와 테스트를 같이 진행함
    - @Transactional을 Test class에 추가해주면 테스트가 끝나고 데이터를 롤백해줌(반영을 안함 / 테스트 각각 트랜잭션을 시작하고 롤백함)
  - 스프링 JdbcTemplate
    - 반복되는 코드 줄어들지만 sql은 직접 짜야함
    - class 생성자가 하나면 @Autowired 생략해도됨
    - 현업에서도 많이 사용함
    - JdbcTemplate 사용하고 통합 테스트 진행해봄
  - JPA
    - spring.jpa.hibernate.ddl-auto 자동으로 테이블도 만들어 주는 여부 결정
    - spring.jpa.show-sql jpa 쿼리를 보여줄지 여부 결정
    - @Entity를 class에 어노테이션하면 jpa에서 관리하는 데이터로 인식
    - id에 @GeneratedValue(strategy = GenerationType.IDENTITY) 붙이면 알아서 자동 생성해줌 (ai같은거인듯)
    - @Column(name = "username") 이런식으로 쓰면 db에 username과 맵핑되서 작동함
    - implementation 'org.springframework.boot:spring-boot-starter-data-jpa' 추가하면 EntityManager는 스프링부트가 알아서 추가해줌
    - em.persist(member); 하면 저장함 (영속적인 뭐 이런뜻인듯)
    - em.createQuery("select m from Member m", Member.class).getResultList();
    객체를 대상으로 쿼리를 날림
    - jpa를 쓰고 서비스에서 데이터를 저장 변경하려면 @Transactional 붙여줘야함 서비스딴에
  - 스프링 데이터 JPA
    - 스프링 데이터 JPA는 인터페이스만 만들어도 클래스를 알아서 만들어준다 (구현 클래스를 딱히 안만들고 사용 가능)
    - 일반적인 기능들은 대부분 제공함 (특정 속성을 찾아 조회나 관리하는건 따로 추가해야함)
    - Optional<Member> findByName(String name); 이런식으로 메서드 이름을 가지고 구현이됨
    - 페이징 기능 자동 제공

- AOP
  - AOP가 필요한 상황
    - 모든 메소드에 호출시간을 측정하려는 상황 (공통관심사항)
  - AOP 적용
    - @Aspect를 적어줘야 AOP로 적용이 가능함
    - @Component 등록해도 되지만 보통 config에 bean 등록해 사용함
    - @Around("execution(* hello.hellospring..*(..))") 이런 문법으로 범위 타겟팅 hello.hellospring 아래는 다하라는 뜻
    - 중간에 인터셉팅해서 사용하는 기술이 AOP 이다
    - 핵심 관심사항과 공통 관심사항을 분리한 기술이다
    - 핵심 관심사항을 깔끔하게 유지할 수 있다